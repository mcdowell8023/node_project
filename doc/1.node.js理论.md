<!-- TOC -->

- [Node.js 理论](#nodejs-%e7%90%86%e8%ae%ba)
  - [事件循环 及工作过程](#%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af-%e5%8f%8a%e5%b7%a5%e4%bd%9c%e8%bf%87%e7%a8%8b)
  - [工作原理](#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86)
  - [ChakraCore 和 Chrome V8 引擎](#chakracore-%e5%92%8c-chrome-v8-%e5%bc%95%e6%93%8e)
  - [CPU 密集型是短板](#cpu-%e5%af%86%e9%9b%86%e5%9e%8b%e6%98%af%e7%9f%ad%e6%9d%bf)
  - [特点](#%e7%89%b9%e7%82%b9)

<!-- /TOC -->

# Node.js 理论

- 09 年诞生
- Node.js 采用事件驱动和异步 I/O 的方式，实现了一个**单线程**、**高并发**的 JavaScript 运行时环境。
- Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 本身 是单线程。
- Node.js 是基于 chrome V8 引擎构建的，由 事件循环（Event Loop）分发 I/O 任务，最终工作线程（workThread）将任务放到线程池（Thread Pool）中执行，而事件循环只要等待执行结果就可以了。
- chrome V8 引擎，用于解释执行 JavaScript 代码
- 事件循环 和 线程池 都是由 libuv 提供的，负责所有的 I/O 任务的分发与执行。

![nki3jg.png](https://s2.ax1x.com/2019/09/03/nki3jg.png)

## 事件循环 及工作过程

Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是**非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用**；如果是 **I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数**，然后继续循环队列中的其他事件。

当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)

![nki9tx.png](https://s2.ax1x.com/2019/09/03/nki9tx.png)

## 工作原理

Node.js 实现异步的核心是**事件**，也就是说，它把每一个任务都当成 事件 来处理，然后通过 Event Loop 模拟了异步的效果。它通过 事件驱动模型 实现了高并发 和 异步 I/O。

Node.js 其实就是帮我们构建了类似排队和叫号的机制。在排队的时候，除了等待我们什么都做不了。但如果有叫号机制，我们就可以先取号码，等轮到自己的时候，系统会发出通知，这中间，我们可以做任何想做的事（在线程池中处理异步 I/O）。写代码的过程实际上就是取号的过程，由事件循环来接受处理，而真正执行操作的是具体的线程池中的 I/O 任务。之所以说 Node.js 是单线程的，是因为它在接受任务的时候是单线程的，无须切换进程/线程，非常高效，但它在执行具体任务的时候是多线程的。

> 一个 nodejs 进程只能使用一个 CPU，要想利用多核 CPU，必须启动多个进程。进程之间使用 IPC 进行通信。
> 由于自己实现这套逻辑略麻烦，所以 Nodejs 提供了 cluster 模块简化多核开发。

## ChakraCore 和 Chrome V8 引擎

Node.js 同时支持 ChakraCore 和 Chrome V8 这两种 JavaScript 引擎二者在性能和特点上各有千秋 ChakraCore 给人感觉更「潮」一些曾是第一个支持 async 函数的引擎，但目前 Node.js 还是以 Chrome V8 引擎为主。

## CPU 密集型是短板

不是所有的任务都是 I/O 密集型任务，当碰到**CPU 密集型**任务时，即只用 CPU 计算的操作，比如要对数据加解密(node.bcrypt.js)，数据压缩和解压(node-tar)，这时 **Node.js 就会亲自处理，一个一个的计算，前面的任务没有执行完，后面的任务就只能干等着**。

在事件队列中，如果前面的 CPU 计算任务没有完成，后面的任务就会被阻塞，出现响应缓慢的情况，如果操作系统本身就是单核，那也就算了，但现在大部分服务器都是多 CPU 或多核的，而 Node.js 只有一个 EventLoop，也就是只占用一个 CPU 内核，当 Node.js 被 CPU 密集型任务占用，导致其他任务被阻塞时，却还有 CPU 内核处于闲置状态，造成资源浪费。

**因此，Node.js 并不适合 CPU 密集型任务。**

[参考：Node.js 事件循环机制](https://www.cnblogs.com/onepixel/p/7143769.html)

## 特点

1. 适合构建 web 应用
2. 高性能：执行速度快，天生异步【事件驱动和非阻塞 I/O】，适用于 I/O 密集的网络应用开发。
3. 简单：语法简单，并发简单，部署运维简单，开发简单
4. 可扩展： 可以使用 npm 上的大量模块， 也可以使用 通过 c、c++扩展实现 cpu 密集型任务，也可以搭配 java、Rust 等语言使用。架构互补，不同的功能业务使用适合的语言。